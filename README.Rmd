---
output: github_document
---

<!-- README.md is generated from README.Rmd. Please edit that file -->

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "man/figures/README-",
  out.width = "100%"
)
```

# hydrorecipes

<!-- badges: start -->

[![CRAN status](https://www.r-pkg.org/badges/version/hydrorecipes)](https://CRAN.R-project.org/package=hydrorecipes)
[![R-CMD-check](https://github.com/jkennel/hydrorecipes/actions/workflows/R-CMD-check.yaml/badge.svg)](https://github.com/jkennel/hydrorecipes/actions/workflows/R-CMD-check.yaml)
[![License: GPL v3](https://img.shields.io/badge/License-GPLv3-blue.svg)](https://www.gnu.org/licenses/gpl-3.0)
[![Codecov test coverage](https://codecov.io/gh/jkennel/hydrorecipes/branch/master/graph/badge.svg)](https://app.codecov.io/gh/jkennel/hydrorecipes?branch=master)
<!-- badges: end -->

The goal of **hydrorecipes** is to supplement the [recipes package](https://recipes.tidymodels.org) with a few steps
that can help deal with moderately sized water level datasets. These were developed primarily with regression deconvolution in mind to be used with *lm* or *glmnet*. The following steps are currently available:

- *step_lead_lag* is a more flexible version of *step_lag* from the [recipes package](https://recipes.tidymodels.org).  Values can be negative which indicates the vector is lead.  In addition, subsetting can be done on the dataset during this process when dealing with very large datasets leading to performance gains without sacrificing temporal accuracy. 
- *step_distributed_lag* is a distributed lag approach for modelling the response in a flexible yet concise manner.  This is useful when you have a long maximum lag or large datasets.
- *step_earthtide* uses the [earthtide package](https://cran.rstudio.com/web/packages/earthtide/index.html) to model the synthetic Earth tide given locations and times. This can provide a single Earth tide curve or a set of harmonics that can be used in regression models.

## Installation

You can install the development version of **hydrorecipes** from [GitHub](https://github.com/) with:

``` r
# install.packages("remotes")
remotes::install_github("jkennel/hydrorecipes")
```

## Example

This is the method of [Kennel 2020](http://hdl.handle.net/10214/17890) which uses a distributed lag model and the [earthtide package](https://cran.rstudio.com/web/packages/earthtide/index.html) to generate synthetic wave groups.  A ~1.5 month dataset of water and barometric pressure having a monitoring frequency of 2 minutes is presented below.  The barometric response is modeled over two days using a distributed lag model with 15 regressor terms. The *knots* are logarithmically separated over two days to accurately capture early and late time responses which can be caused by different physical mechanisms.

```{r message = FALSE}
library(hydrorecipes)
library(earthtide)
library(tidyr)
library(ggplot2)

data(transducer)

# convert to numeric because step_ns doesn't handle POSIXct
transducer$datetime <- as.numeric(transducer$datetime)

unique(diff(transducer$datetime)) # times are regularly spaced

# Earth tide inputs
wave_groups <- earthtide::eterna_wavegroups
wave_groups <- na.omit(wave_groups[wave_groups$time == '1 month', ])
wave_groups <- wave_groups[wave_groups$start > 0.5, ]
latitude  <- 34.0
longitude <- -118.5

# create recipe 
rec <- recipe(wl~baro+datetime, transducer) |>
  step_distributed_lag(baro, knots = log_lags(15, 86400 * 2 / 120)) |>
  step_earthtide(datetime,
                 latitude = latitude,
                 longitude = longitude,
                 astro_update = 1,
                 wave_groups = wave_groups) |>
  step_ns(datetime, deg_free = 10) |>
  prep()

input <- rec |> bake(new_data = NULL)
```

```{r}
summary(fit <- lm(wl~., input))
```


## Decomposition

```{r fig.height = 12, fig.width = 12, out.width = '90%'}
pred <- predict_terms(fit = fit, 
                      rec = rec,
                      data = input)
pred <- bind_cols(transducer[, c('datetime', 'wl')], pred)
pred_long <- pivot_longer(pred, cols = !datetime)
ggplot(pred_long, aes(x = datetime, y = value)) +
  geom_line() + 
  facet_grid(name~., scales = 'free_y') + 
  theme_bw()
```

## Response

```{r fig.height = 5, fig.width = 10, out.width = '90%'}

resp <- response(fit, rec)
resp_ba <- resp[resp$name == 'cumulative', ]
resp_ba <- resp_ba[resp_ba$term == 'baro', ]

ggplot(resp_ba, aes(x = x * 120 / 3600, y = value)) +
  ggtitle('Barometric Loading Response') + 
  xlab('lag (hours)') +
  ylab('Cumulative response') +
  scale_y_continuous(limits = c(0, 1)) +
  geom_line() + 
  theme_bw()


resp_et <- resp[resp$name %in% c('amplitude', 'phase'), ]
ggplot(resp_et, aes(x = x, xend = x, y = 0, yend = value)) +
  geom_segment() + 
  ggtitle('Earthtide Response') +
  xlab('Frequency (cycles per day)') +
  facet_grid(name~., scales = 'free_y') + 
  theme_bw()

```
